# Lesson 5 - Thread Life Cycle Overview

1. 调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。
	* Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：
		1. static int MAX_PRIORITY: 线程可以具有的最高优先级，取值为10。
		1. static int MIN_PRIORITY: 线程可以具有的最低优先级，取值为1。
		1. static int NORM_PRIORITY: 分配给线程的默认优先级，取值为5。
	* Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。
 	* 每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。
	* 线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。
	* JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。
 
1. 线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。
 
1. 线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。
 
1. 线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。
 
1. 线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。
 
1. 线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。
