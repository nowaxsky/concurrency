# Lesson 6 - Thread Yield

## Thread Status

![Alt text](./l4.jpg "Thread Status")

1. 新建状态（New）：新创建了一个线程对象。
1. 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
1. 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
1. 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
	* 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)
	* 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
	* 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）
1. 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

## Thread 調度

1. 调整线程优先级: 
	* Java线程有优先级，优先级高的线程会获得较多的运行机会。
	* Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：
		1. static int MAX_PRIORITY: 线程可以具有的最高优先级，取值为10。
		1. static int MIN_PRIORITY: 线程可以具有的最低优先级，取值为1。
		1. static int NORM_PRIORITY: 分配给线程的默认优先级，取值为5。
	* Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。
 	* 每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。
	* 线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。
	* JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。
	* setPriority可以設定 1~10, 預設值是5, 數字越大優先權越高.
	* 優先權低不代表一定比較晚執行, 只是代表他們同時競爭相同資源時, 會先給優先權大的.
1. 线程睡眠:
	* Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。
	* sleep(long millis)在指定的毫秒数内让当前正在执行的线程休眠(暂停执行).
	* sleep是讓當前的thread暫停工作, 呼叫繼承Thread的類別的sleep也只能暫停"當前"的執行緒
1. join():
	* 等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。
	* threadB.join()意思為等待B執行緒完成後該程式才會繼續執行, 是主執行緒等待子執行緒的方法.
	* 在很多情况下如果子线程里要进行大量的耗时的运算, 主线程往往将于子线程之前结束, 但是如果主线程处理完其他的事务后需要用到子线程的处理结果, 即主线程需要等待子线程执行完成之后再结束, 这个时候就要用到join()方法了.
1. 線程讓步:
	* yield()暂停当前正在执行的线程对象, 把执行机会让给相同或者更高优先级的线程.
	* yield是让当前运行线程回到可运行状态, 所以__無法保證yield()达到让步目的__, 因为让步的线程还有可能被线程调度程序再次选中.
	* __yield从未导致线程转到等待/睡眠/阻塞状态, 在大多数情况下yield将导致线程从运行状态转到可运行状态, 但有可能没有效果.__
	* yield不會讓給優先級比自己低的執行緒執行, 且讓出的時間不可控(因為只是回到可運行狀態, 和sleep下的不可運行狀態不同).