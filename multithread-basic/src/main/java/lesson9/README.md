# Lesson 9 - Thread Data Transfer

在传统的同步开发模式下, 当我们调用一个函数时, 通过这个函数的参数将数据传入, 并通过这个函数的返回值来返回最终的计算结果. 但在多线程的异步开发模式下, 数据的传递和返回和同步开发模式有很大的区别. 由于线程的运行和结束是不可预料的, 因此, 在传递和返回数据时就无法象函数一样通过函数参数和return语句来返回数据. 

## 資料傳遞方法
1. ConstructorDemo(建構式傳遞參數)
	* 这种方法是在创建线程对象的同时传递数据的, 因此, 在线程运行之前这些数据就就已经到位了, 这样就不会造成数据在线程运行后才传入的现象. 
	* 如果要传递更复杂的数据, 可以使用集合、类等数据结构. 使用构造方法来传递数据虽然比较安全, 但如果要传递的数据比较多时, 就会造成很多不便. 
	* 由于Java没有默认参数, 要想实现类似默认参数的效果, 就得使用重载, 这样不但使构造方法本身过于复杂, 又会使构造方法在数量上大增. 因此, 要想避免这种情况, 就得通过类方法或类变量来传递数据.  

1. MethodDemo(方法或變數傳遞參數)
	* 向对象中传入数据一般有两次机会, 第一次机会是在建立对象时通过构造方法将数据传入, 另外一次机会就是在类中定义一系列的public的方法或变量(也可称之为字段). 然后在建立完对象后, 通过对象实例逐个赋值. 
1. CallbackDemo
	* 上面讨论的两种向线程中传递数据的方法是最常用的. 但这两种方法都是main方法中主动将数据传入线程类的. 这对于线程来说, 是被动接收这些数据的. 然而, 在有些应用中需要在线程运行的过程中动态地获取数据, 如在下面代码的run方法中产生了3个随机数, 然后通过Work类的process方法求这三个随机数的和, 并通过Data类的value将结果返回. 从这个例子可以看出, 在返回value之前, 必须要得到三个随机数. 也就是说, 这个 value是无法事先就传入线程类的.
	* Callback(回調函數)的詳解請看appendix.callback.

## Thread Noun
1. 主线程：JVM调用程序main()所产生的线程. 
1. 当前线程：这个是容易混淆的概念. 一般指通过Thread.currentThread()来获取的进程. 
1. 守护线程：指为其他线程提供服务的线程, 也称为后台线程. JVM的垃圾回收线程就是一个后台线程. __用户线程和守护线程的区别在于, 是否等待主线程依赖于主线程结束而结束.(JVM會在所有的用戶線程結束後關閉, 亦即當所有的線程均為守護線程時, JVM會關閉)__
1. 前台线程：是指接受后台线程服务的线程, 其实前台后台线程是联系在一起, 就像傀儡和幕后操纵者一样的关系. 傀儡是前台线程、幕后操纵者是后台线程. 由前台线程创建的线程默认也是前台线程. 可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程. __(调用线程对象的方法setDaemon(true), 则可以将其设置为守护线程. )__
1. 線程常用方法: 
	* sleep(n): 强迫一个线程睡眠n毫秒.  
	* isAlive(): 判断一个线程是否存活.  
	* join(): 等待线程终止.  
	* activeCount(): 程序中活跃的线程数.  
	* enumerate(): 枚举程序中的线程.  
	* currentThread(): 得到当前线程.  
	* isDaemon(): 一个线程是否为守护线程.  
	* setDaemon(): 设置一个线程为守护线程. (用户线程和守护线程的区别在于, 是否等待主线程依赖于主线程结束而结束) 
	* setName(): 为线程设置一个名称.  
	* wait(): 强迫一个线程等待.  
	* notify(): 通知一个线程继续运行.  
	* setPriority(): 设置一个线程的优先级. 

